#!/bin/bash

# Parse options from the main script
_parse_here_options() {
  echo $(cat `which here` | grep -E '\--[a-z-]+' | sed -E 's/^.*(--[a-z-]+).*$/\1/')
}

_complete_options() {
  local cur="$1"

  # Parse options from the script
  local _options=$(_parse_here_options)
  # Use a backslash to avoid compgen treating the current word as its own argument
  echo $(compgen -W "${_options[*]}" "\\${cur}")
}

_complete_commands() {
  local cur="$1"
  local bin_dir=$(here --dir)

  # Switch to directory for this path and use file completion from there to get commands
  echo $([[ -d $bin_dir ]] && cd "$bin_dir" && compgen -f -- "${cur}")
}

_here_completion() {
  local cur="$2"
  local num_words=${#COMP_WORDS[@]}
  local num_args=$(( $num_words - 1 ))

  local first_word=${COMP_WORDS[1]}

  # Complete options or commands when on the first item
  if [[ $num_args == 1 ]]; then
    # Combine commands and options and let them get filtered by current word
    COMPREPLY=( $(_complete_commands "$cur") $(_complete_options "$cur") )

  # Complete commands after the `--edit` param
  elif [[ $num_args == 2 && "$first_word" == "--edit" ]]; then
    COMPREPLY=( $(_complete_commands "$cur") )

  # Don't complete after other params
  elif [[ $num_args == 2 && "$first_word" == "--"* ]]; then
    COMPREPLY=()

  # Don't complete after `--edit <command>`
  elif [[ $num_args == 3 && "$first_word" == "--edit" ]]; then
    COMPREPLY=()

  # Fallback to file completion
  else
    COMPREPLY=( $(compgen -o default -- "${cur}") )
  fi
}

complete -F _here_completion here
